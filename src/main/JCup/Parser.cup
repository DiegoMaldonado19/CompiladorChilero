/* Paquete donde se guardará la clase */
package com.compiladorchilero.analyzers;

/* Imports necesarios */
import java.util.*;
import java_cup.runtime.*;
import com.compiladorchilero.models.*;

class Parser;

/* Codigo de usuario */
parser code {:
    private LinkedList<Instruction> AST;
    private LinkedList<String> errorList;

    public Parser(Lexer lex){
        super(lex);
        this.AST = new LinkedList<Instruction>();
        this.errorList = new LinkedList<String>();
    }

     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Token token){ 
        errorList.add(String.format(report_error("Se encontro un error sintactico con el token: "+token.getLexeme()+" en la linea: "+token.getLine()+" en la columna: "+token.getColumn())));
    } 

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        errorList.add(String.format(report_error("Error síntactico irrecuperable con el token: "+token.getLexeme()+" en la linea: "+token.getLine()+" en la columna: "+token.getColumn()))); 
    }  

    public LinkedList<Instruction> getAST() {
        return AST;
    }
:}

/* Declaracion de terminales */
terminal Token LBRACE;
terminal Token RBRACE;
terminal Token COLON;
terminal Token COMMA;
terminal Token SEMICOLON;
terminal Token LPAREN;
terminal Token RPAREN;
terminal Token EQUALS;
terminal Token PLUS;
terminal Token MINUS;
terminal Token MULT;
terminal Token DIV;
terminal Token LT; /*<=*/
terminal Token GT; /*>=*/
terminal Token EXCLAMATION;
terminal Token OR;
terminal Token INT;
terminal Token STRING;
terminal Token FLOAT;
terminal Token IF;
terminal Token ELSE;
terminal Token FOR;
terminal Token WHILE;
terminal Token READ;
terminal Token WRITE;
terminal Token IDENTIFIER;
terminal Token INT_CONST;
terminal Token STR_CONST;
terminal Token FLOAT_CONST;
terminal Token INCREMENT;
terminal Token DECREMENT;
terminal Token CHARACTER;
terminal Token CHARACTER_CONST;
terminal Token UMENOS;

/* Declaracion de elementos no terminales */
non terminal file;
non terminal LinkedList<Instruction> instructions_list;
non terminal Instruction instruction;
non terminal LinkedList<Instruction> else_ifs;
non terminal LinkedList<Instruction> case_list;
non terminal Instruction case_statement;
non terminal Operation numerical_expresion;
non terminal Operation string_expression;
non terminal Operation logical_expression;
non terminal Operation expressions;

/* Declaracion de precedencia */
precedence left PLUS, MINUS;
precedence left DIV, MULT;
precedence right UMENOS;
precedence nonassoc LPAREN, RPAREN;
precedence nonassoc INCREMENTO,DECREMENTO; 

/* Definimos con que simbolo no terminal inicia */
start with file;

file ::=  instructions_list:a
        ;

instructions_list ::=   instructions_list:a instruction:b   {: RESULT = a; RESULT.add(b); :}
                    |   instruction:a                       {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                    ;

instruction ::=  WRITE LPAREN string_expression:a RPAREN SEMICOLON                                                                          {: RESULT = new Print(a); :}
              |  READ LPAREN IDENTIFIER:a RPAREN SEMICOLON                                                                                  {: RESULT = new Read(a.getLexeme); :}
              |  INT IDENTIFIER:a SEMICOLON                                                                                                 {: RESULT = new Declaration(a.getLexeme(), Type.NUMBER); :}
              |  STRING IDENTIFIER:a SEMICOLON                                                                                              {: RESULT = new Declaration(a.getLexeme(), Type.STRING); :}
              |  FLOAT IDENTIFIER:a SEMICOLON                                                                                               {: RESULT = new Declaration(a.getLexeme(), Type.FLOAT); :}
              |  CHARACTER IDENTIFIER:a SEMICOLON                                                                                           {: RESULT = new Declaration(a.getLexeme(), Type.CHARACTER); :}
              |  IDENTIFIER:a EQUALS expression:b SEMICOLON                                                                                 {: RESULT = new Assignment(a.getLexeme(), b); :}
              |  IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE                                                    {: RESULT = new If(a,b); :}
              |  IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE ELSE LBRACE instructions_list:c RBRACE             {: RESULT = new If(a,b,c); :}
              |  IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE else_ifs:c                                         {: RESULT = new If(a,b,c,null); :}
              |  IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE else_ifs:c ELSE RBRACE instructions_list:d LBRACE  {: RESULT = new If(a,b,c,d); :}
              |  IDENTIFIER INCREMENT SEMICOLON                                                                                             {: RESULT = new Increment(a.getLexeme()); :}
              |  IDENTIFIER DECREMENT SEMICOLON                                                                                             {: RESULT = new Decrement(a.getLexeme()); :}
              |  SWITCH LPAREN IDENTIFIER:a RPPAREN LBRACE case_list:b RBRACE                                                               {: RESULT = new Switch(a, b); :}
              |  error
              ;

else_ifs ::= else_ifs:a ELSE LPAREN logical_expression:b RPAREN LBRACE instructions_list:c RBRACE       {: RESULT = a; RESULT.add(new If(b,c)); :}
           | ELSE IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:B RBRACE               {: RESULT = new LinkedList<>(); RESULT.add(new If(a,b)) :}
           ;

case_list ::= case_list:a case_statement:b       {: RESULT = a; RESULT.add(b); :}
            | case_statement:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
            ;

case_statement ::= CASE expressions:a COLON instructions_list:b BREAK SEMICOLON      {: RESULT = new Case(a, b); :}
            ;

numerical_expresion ::=    numerical_expresion:a PLUS numerical_expresion:b                        {: RESULT = new Operation(a, b, Operation.OperationType.ADDITION); :}
                |          numerical_expresion:a MINUS  numerical_expresion:b                      {: RESULT = new Operation(a, b, Operation.OperationType.SUBSTRACTION); :}
                |          numerical_expresion:a MULT  numerical_expresion:b                       {: RESULT = new Operation(a, b, Operation.OperationType.MULTIPLICATION); :}
                |          numerical_expresion:a DIV  numerical_expresion:b                        {: RESULT = new Operation(a, b, Operation.OperationType.DIVISION); :}
                |          MINUS  numerical_expresion:a                                            {: RESULT = new Operation(a, Operation.OperationType.NEGATVE); :}%prec UMINUS
                |          LPAREN  numerical_expresion:a RPAREN                                    {: RESULT = a; :} 
                |          INT_CONST:a                                                             {: RESULT = new Operation(new Double(a)); :}
                |          FLOAT_CONST:a                                                           {: RESULT = new Operation(new Double(a)); :}
                |          CHARACTER_CONST:a                                                       {: RESULT = new Operation(a, Operation.OperationType.CHARACTER); :}
                |          IDENTIFIER:a                                                            {: RESULT = new Operation(a, Operation.OperationType.IDENTIFIER); :}
                ;

string_expression ::=   STR_CONST:a                   {: RESULT = new Operation(a, Operation.OperationType.STRING); :}
                    |   numerical_expresion:a         {: RESULT = a; :}
                    ;
                    
logical_expression ::=  expressions:a EQUALS EQUALS expressions:b                  {: RESULT = new Operation(a, b, Operation.OperationType.EQUALS_EQUALS); :}
                     |  numerical_expresion:a LT numerical_expresion:b             {: RESULT = new Operation(a, b, Operation.OperationType.LESS_THAN); :}
                     |  numerical_expresion:a GT numerical_expresion:b             {: RESULT = new Operation(a, b, Operation.OperationType.GREATHER_THAN); :}
                     |  numerical_expresion:a LT EQUALS numerical_expresion:b      {: RESULT = new Operation(a, b, Operation.OperationType.LESS_THAN_EQUALS); :}
                     |  numerical_expresion:a GT EQUALS numerical_expresion:b      {: RESULT = new Operation(a, b, Operation.OperationType.GREATHER_THAN_EQUALS); :}
                     ;        

expressions ::= string_expression:a         {: RESULT = a; :}
              | numerical_expresion:a       {: RESULT = a; :}
              | logical_expression:a        {: RESULT = a; :}
              ;