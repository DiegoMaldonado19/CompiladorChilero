/* Paquete donde se guardará la clase */
package com.compiladorchilero.analyzers;

/* Imports necesarios */
import java.util.*;
import javax.swing.JTextArea;
import com.compiladorchilero.models.*;
import com.compiladorchilero.controllers.*;

class Parser;

/* Codigo de usuario */
parser code {:
    private LinkedList<Instruction> AST;
    private LinkedList<String> errorList;
    private JTextArea textArea;

    public Parser(Lexer lex, JTextArea textArea){
        super(lex);
        this.AST = new LinkedList<Instruction>();
        this.errorList = new LinkedList<String>();
        this.textArea = textArea;
    }

    public void syntax_error(Token token){ 
        errorList.add("Error Sintáctico en la Línea " + token.getLine() +" Columna "+token.getColumn()+ ". No se esperaba este componente: " +token.getLexeme()+".");
    } 

    public void unrecovered_syntax_error(Token token) throws java.lang.Exception{ 
        errorList.add("Error síntactico irrecuperable en la Línea " + token.getLine()+ " Columna "+token.getColumn()+". Componente " + token.getLexeme() + " no reconocido.");
    }  

    public LinkedList<Instruction> getAST() {
        return AST;
    }

    public LinkedList<String> getErrorList(){
        return errorList;
    }
:}

/* Declaracion de terminales */
terminal Token LBRACE;
terminal Token RBRACE;
terminal Token COLON;
terminal Token COMMA;
terminal Token SEMICOLON;
terminal Token LPAREN;
terminal Token RPAREN;
terminal Token EQUALS;
terminal Token PLUS;
terminal Token MINUS;
terminal Token MULT;
terminal Token DIV;
terminal Token LT; /*<*/
terminal Token GT; /*>*/
terminal Token EXCLAMATION;
terminal Token OR;
terminal Token INT;
terminal Token STRING;
terminal Token FLOAT;
terminal Token IF;
terminal Token ELSE;
terminal Token FOR;
terminal Token WHILE;
terminal Token READ;
terminal Token WRITE;
terminal Token IDENTIFIER;
terminal Token INT_CONST;
terminal Token STR_CONST;
terminal Token FLOAT_CONST;
terminal Token INCREMENT;
terminal Token DECREMENT;
terminal Token CHARACTER;
terminal Token CHARACTER_CONST;
terminal Token UMINUS;
terminal Token SWITCH;
terminal Token CASE;
terminal Token DEFAULT;
terminal Token BREAK;
terminal Token TRUE;
terminal Token False;


/* Declaracion de elementos no terminales */
non terminal file;
non terminal LinkedList<Instruction> instructions_list;
non terminal Instruction instruction;
non terminal LinkedList<Instruction> else_ifs;
non terminal LinkedList<Instruction> case_list;
non terminal Instruction case_statement;
non terminal Operation numerical_expresion;
non terminal Operation string_expression;
non terminal Operation logical_expression;
non terminal Operation values;
non terminal Operation boolean_value;

/* Declaracion de precedencia */
precedence left PLUS, MINUS;
precedence left DIV, MULT;
precedence right UMINUS;
precedence nonassoc LPAREN, RPAREN;
precedence nonassoc INCREMENT,DECREMENT; 

/* Definimos con que simbolo no terminal inicia */
start with file;

file ::=  instructions_list:a   {: parser.AST=a; :}
        ;

instructions_list ::=   instructions_list:a instruction:b   {: RESULT = a; RESULT.add(b); :}
                    |   instruction:a                       {: RESULT = new LinkedList<>(); RESULT.add(a); :}
                    ;

instruction ::=  WRITE LPAREN string_expression:a RPAREN SEMICOLON                                                                          {: RESULT = new Print(a, this.parser.textArea); :}/*
              |  READ LPAREN IDENTIFIER:a RPAREN SEMICOLON                                                                                  {: RESULT = new Read(a.getLexeme); :}*/
              |  INT IDENTIFIER:a SEMICOLON                                                                                                 {: RESULT = new Declaration(a.getLexeme(), Type.NUMBER); :}
              |  STRING IDENTIFIER:a SEMICOLON                                                                                              {: RESULT = new Declaration(a.getLexeme(), Type.STRING); :}
              |  FLOAT IDENTIFIER:a SEMICOLON                                                                                               {: RESULT = new Declaration(a.getLexeme(), Type.FLOAT); :}
              |  CHARACTER IDENTIFIER:a SEMICOLON                                                                                           {: RESULT = new Declaration(a.getLexeme(), Type.CHARACTER); :}
              |  BOOLEAN IDENTIFIER:a SEMICOLON                                                                                             {: RESULT = new Declaration(a.getLexeme(), Type.BOOLEAN;); :}
              |  IDENTIFIER:a EQUALS values:b SEMICOLON                                                                                     {: RESULT = new Assignment(a.getLexeme(), b); :}
              |  IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE                                                    {: RESULT = new If(a,b); :}
              |  IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE ELSE LBRACE instructions_list:c RBRACE             {: RESULT = new If(a,b,c); :}
              |  IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE else_ifs:c                                         {: RESULT = new If(a,b,c,null); :}
              |  IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE else_ifs:c ELSE RBRACE instructions_list:d LBRACE  {: RESULT = new If(a,b,c,d); :}
              |  IDENTIFIER:a INCREMENT SEMICOLON                                                                                             {: RESULT = new Increment(a.getLexeme()); :}
              |  IDENTIFIER:a DECREMENT SEMICOLON                                                                                             {: RESULT = new Decrement(a.getLexeme()); :}
              |  WHILE LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE                                                 {: RESULT = new While(a, b); :}
              |  FOR LPAREN INT_CONST:a COMMA INT_CONST:b RPAREN LBRACE instructions_list:c RBRACE                                          {: RESULT = new For(Integer.valueOf(String.valueOf(a)), Integer.valueOf(String.valueOf(b)), c); :}                
              |  SWITCH LPAREN IDENTIFIER:a RPAREN LBRACE case_list:b RBRACE                                                               {: RESULT = new Switch(a, b); :}
              |  error
              ;

else_ifs ::= else_ifs:a ELSE LPAREN logical_expression:b RPAREN LBRACE instructions_list:c RBRACE       {: RESULT = a; RESULT.add(new If(b,c)); :}
           | ELSE IF LPAREN logical_expression:a RPAREN LBRACE instructions_list:b RBRACE               {: RESULT = new LinkedList<>(); RESULT.add(new If(a,b)); :}
           ;

case_list ::= case_list:a CASE values:b COLON instructions_list:c BREAK SEMICOLON        {: RESULT = a; RESULT.add(new Case(b, c)); :}
            | CASE values:a COLON instructions_list:b BREAK SEMICOLON                    {: RESULT = new LinkedList<>(); RESULT.add(new Case(a, b)); :}
            ;

case_statement ::= CASE values:a COLON instructions_list:b BREAK SEMICOLON      {: RESULT = new Case(a, b); :}
                |  DEFAULT COLON instructions_list:a BREAK SEMICOLON                   {: RESULT = new Case(a); :}
            ;

numerical_expresion ::=    numerical_expresion:a PLUS numerical_expresion:b                        {: RESULT = new Operation(a, b, OperationType.ADDITION); :}
                |          numerical_expresion:a MINUS  numerical_expresion:b                      {: RESULT = new Operation(a, b, OperationType.SUBSTRACTION); :}
                |          numerical_expresion:a MULT  numerical_expresion:b                       {: RESULT = new Operation(a, b, OperationType.MULTIPLICATION); :}
                |          numerical_expresion:a DIV  numerical_expresion:b                        {: RESULT = new Operation(a, b, OperationType.DIVISION); :}
                |          MINUS  numerical_expresion:a                                            {: RESULT = new Operation(a, OperationType.NEGATIVE); :}%prec UMINUS
                |          LPAREN  numerical_expresion:a RPAREN                                    {: RESULT = a; :} 
                |          INT_CONST:a                                                             {: RESULT = new Operation(new Double(a.getLexeme())); :}
                |          FLOAT_CONST:a                                                           {: RESULT = new Operation(new Double(a.getLexeme())); :}
                |          CHARACTER_CONST:a                                                       {: RESULT = new Operation(a.getLexeme(), OperationType.CHARACTER); :}
                |          IDENTIFIER:a                                                            {: RESULT = new Operation(a.getLexeme(), OperationType.IDENTIFIER); :}
                ;
                    
logical_expression ::=  /*expressions:a EQUALS EQUALS expressions:b                  {: RESULT = new Operation(a, b, Operation.OperationType.EQUALS_EQUALS); :}*/
                     |  numerical_expresion:a LT numerical_expresion:b             {: RESULT = new Operation(a, b, OperationType.LESS_THAN); :}
                     |  numerical_expresion:a GT numerical_expresion:b             {: RESULT = new Operation(a, b, OperationType.GREATHER_THAN); :}
                     |  numerical_expresion:a LT EQUALS numerical_expresion:b      {: RESULT = new Operation(a, b, OperationType.LESS_THAN_EQUALS); :}
                     |  numerical_expresion:a GT EQUALS numerical_expresion:b      {: RESULT = new Operation(a, b, OperationType.GREATHER_THAN_EQUALS); :}
                     ;        

expressions ::= string_expression:a         {: RESULT = a; :}
              | logical_expression:a        {: RESULT = a; :}
              ;

value ::= numerical_expresion       {: RESULT = a; :}
        | STR_CONST                 {: RESULT = new Operation(a.getLexeme(), OperationType.STRING); :}
        | boolean_value             {: RESULT = a; :}
        ;

boolean_value ::=   TRUE            {: RESULT = new Operation(a.getLexeme(), OperationType.BOOLEAN); :}
                |   FALSE           {: RESULT = new Operation(a.getLexeme(), OperationType.BOOLEAN); :}
                ;
